#!/usr/bin/env python
# encoding: utf-8

import sys
import os, os.path
import dm.sdk
from dm.sdk.client import Client
from prettytable import PrettyTable
import yaml
import logging
import traceback
import select
import pprint
pp = pprint.PrettyPrinter()

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter

LIMIT = 5000
REMOTE = 'https://dm.csirtgadgets.com/api'
TIMEOUT = 300

__all__ = []
__version__ = dm.sdk.__version__
__max_field_size__ = 30

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg
    def __str__(self):
        return self.msg
    def __unicode__(self):
        return self.msg

def main(argv=None): # IGNORE:C0111
    '''Command line options.'''
    
    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    program_name = os.path.basename(sys.argv[0])
    program_version = "v%s" % __version__
    program_version_message = '%%(prog)s %s' % (program_version)

    try:
        # Setup argument parser
        parser = ArgumentParser(description='', formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-v", "--verbose", dest="verbose", action="count", help="set verbosity level [default: %(default)s]")
        parser.add_argument('-d', '--debug', dest='debug', action="store_true")
        parser.add_argument('-V', '--version', action='version', version=program_version_message)

        parser.add_argument('-q',"--search", dest="search", help="search for observable")
        parser.add_argument('--token', dest='token', help="specify token")
        parser.add_argument('--limit', dest="limit", help="result limit", default=LIMIT)
        parser.add_argument('--no-verify-ssl', dest="no_verify_ssl", action="store_true", default=False)
        parser.add_argument('--remote', dest="remote", help="remote api location [default: %(default)s]",
                            default=REMOTE)
        parser.add_argument('--timeout', dest="timeout", help='connection timeout [default: %(default)s]',
                            default=TIMEOUT)
        parser.add_argument('-C', '--config', dest="config", help="configuration file [default: %(default)s]",
                            default=os.path.expanduser("~/.dm.yml") )
        parser.add_argument('--ping', dest="ping", action="store_true", help="ping")
        parser.add_argument('--submit', help="submit json string")

        parser.add_argument('--feed', dest='feed')
        parser.add_argument('--user', dest='user')


        
        # Process arguments
        args = parser.parse_args()
        
        # setup the initial console logging
        fmt = '%(asctime)s - %(levelname)s - %(name)s::%(threadName)s - %(message)s'
        loglevel = logging.WARNING
        if args.verbose:
            loglevel = logging.INFO
        if args.debug:
            loglevel = logging.DEBUG
        
        console = logging.StreamHandler()
        logging.getLogger('').setLevel(loglevel)
        console.setFormatter(logging.Formatter(fmt))
        logging.getLogger('').addHandler(console)
        logger = logging.getLogger(__name__)

        options = vars(args)

        # TODO -- defaults
        if os.path.isfile(args.config):
            f = file(args.config)
            config = yaml.load(f)
            f.close()
            if not config['client']:
                raise Exception("Unable to read " + args.config + " config file")
            config = config['client']
            for k in config:
                if not options.get(k):
                    options[k] = config[k]

        cli = Client(**options)

        if(options.get('submit')):
            ret = cli.submit(feed=options.get('feed'), user=options.get('user'), data={
                'observable': {
                    'thing': 'example.com'
                }
            })
            pp.pprint(ret)
        elif(options.get('feed')):
            filters = {}
            if options.get('search'):
                filters['observable'] = options['search']


            ret = cli.feed(user=options['user'], feed=options['feed'])
            print cli.table(data=ret)
        elif(options.get('ping')):
            for num in range(0,4):
                ret = Client(**options).ping()
                print "roundtrip: %s ms" % ret
                select.select([], [], [], 1)
        else:
            logger.warning('operation not supported')
            sys.exit()

    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0
    except Exception, e:
        traceback.print_exc(file=sys.stdout)
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help")
        return 2

if __name__ == "__main__":
    sys.exit(main())
